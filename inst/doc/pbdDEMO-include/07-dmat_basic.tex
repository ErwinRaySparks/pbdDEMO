

%%% ----------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Basic Examples}

There is a deep part of the author that does not want to begin with these examples.  There is a real danger for the cursory observer to see these and hastily conclude that our work, or \proglang{R} as a whole, is merely a ``Matlab Clone.''  Nothing could be further from reality.

Matlab is an amazing product.  It costs \$100,000; it had better damn well be.  However, for statistics, machine learning, data mining --- data science --- we believe that \proglang{R} is ``better.''  Is \proglang{R} faster?  No, probably not.  But we argue that \proglang{R} wins in other ways.

It is true that everything \proglang{R} can do, so too can Matlab; of course, the converse is also true --- that everything Matlab can do, \proglang{R} can do as well.  Each is a turing complete language.  But being turing complete is not sufficient; \LaTeX\ is turing complete, and yet we do not perform scientific computation in it (although of course it is unparalleled in typesetting).  But we could.  

The fact that we do not is an extension of the fact that math journals do not publish articles written in \proglang{C} or \proglang{Fortran}.  Those programming languages are the wrong mediums of abstraction for expressing highly complicated ideas to domain experts.  Only a madman would attempt to express deep mathematical abstraction in these languages for publication (implementation being an entirely separate issue).  Likewise, we do not perform our statistical analyses in \LaTeX\ (don't be a pedant; we are not talking about sweave and you know it).  People overwhelmingly choose \proglang{R} for the analysis of data because it is the closest brain~$\rightarrow$~computer translation available for such problems.

Of course, this goes both ways.  If your life is matrix algebra, then \proglang{R} is a much worse fit for you than is Matlab.  Much of statistics is applied matrix algebra, but not all matrix algebra is statistics.

So we reluctantly press on with several basic examples utilizing distributed matrices.  For meatier examples, see Chapter~\ref{chpt:avdstat}.




\section{Reductions and Transformations}

\subsection{Reductions}

In Section~\ref{sub:diag}, we discussed the way that the \code{diag()} method may be utilized as a reduction operator.  We have numerous other reductions available, such as \code{sum()}, \code{prod()}, \code{min()}, and \code{max()}.  These operate exactly as their serial counterparts:
\begin{lstlisting}[language=rr,title=Reductions]
library(pbdDMAT, quiet = TRUE)
init.grid()

comm.set.seed(diff = TRUE)

dx <- ddmatrix(data=0:1, nrow=10, ncol=10)

sm <- sum(dx)
comm.print(sm)

pd <- prod(dx)
comm.print(pd)

mn <- min(dx)
comm.print(mn)

mx <- max(dx)
comm.print(mx)

finalize()
\end{lstlisting}

We also offer some ``super reductions''.  It is possible to change a distributed matrix into a non-distributed matrix or vector using the methods \code{as.matrix()} or \code{as.vector()}.  For example:

\begin{lstlisting}[language=rr,title=Super Reductions]
library(pbdDMAT, quiet = TRUE)
init.grid()

comm.set.seed(diff = TRUE)

dx <- ddmatrix(data=0:1, nrow=10, ncol=10)
print(dx)

x <- as.matrix(dx)
comm.print(x)

finalize()
\end{lstlisting}

These can be very useful in testing, but should be used sparingly at scale.




\subsection{Transformations}

We also offer numerous in-place transformations, such as the various \code{log()} functions, \code{abs()}, \code{sqrt()}, \code{ceiling()}, \code{floor()}, and \code{round()}.  For example:

\begin{lstlisting}[language=rr,title=Transformations]
library(pbdDMAT, quiet = TRUE)
init.grid()

comm.set.seed(diff = TRUE)

dx <- ddmatrix(data=-3:3, nrow=10, ncol=10)

dx <- ceiling(sqrt(abs(dx)))

x <- as.matrix(dx)
comm.print(x)

finalize()
\end{lstlisting}





\section{Matrix Arithmetic}

We also offer a complete set of methods for distributed matrix arithmetic.  With identical syntax to \proglang{R}, we can do some fairly complicated things, such as:

\begin{lstlisting}[language=rr,title=Transformations]
library(pbdDMAT, quiet = TRUE)
init.grid()

comm.set.seed(diff = TRUE)

dx <- ddmatrix(data=-3:3, nrow=10, ncol=10)
vec <- 1:2

dy <- (dx - vec) %*% dx

y <- as.matrix(dy)
comm.print(y)

finalize()
\end{lstlisting}

For a full list of methods, see the \pkg{pbdDMAT} documentation.




% 
% \section{Matrix Factorizations}
% 
% svd, qr, chol
