\part{Distributed Matrix Methods}
\label{part:dmat}

%%% ----------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Basic Examples}

There is a deep part of the author that does not want to begin with these examples.  There is a real danger for the cursory observer to see these and hastily conclude that our work, or \proglang{R} as a whole, is merely a ``Matlab Clone.''  Nothing could be further from reality.

Matlab is an amazing product.  It costs \$100,000; it had better damn well be.  However, for statistics, machine learning, data mining --- data science --- we believe that \proglang{R} is ``better.''  Is \proglang{R} faster?  No, probably not.  But we argue that \proglang{R} wins in other ways.

It is true that everything \proglang{R} can do, so too can Matlab; of course, the converse is also true --- that everything Matlab can do, \proglang{R} can do as well.  Each is a turing complete language.  But being turing complete is not sufficient; \LaTeX\ is turing complete, and yet we do not perform scientific computation in it (although of course it is unparalleled in typesetting).  But we could.  Consider Project Euler problem 2:  Find the sum of all the even-valued Fibonacci numbers which do not exceed four million.  Using \LaTeX:

\begin{lstlisting}
documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
 
\usepackage{forloop}  
\usepackage{fp}  
 
\begin{document}
 
\newcounter{sum}
\newcounter{current}
\newcounter{prev}
\newcounter{prevprev}
\newcounter{n}
 
\FPset{\sum}{0}
\FPset{\prev}{1}
\FPset{\prevprev}{1}
\FPset{\current}{2}
 
\forloop{n}{1}{\value{n} < 2}{
    \FPdiv{\test}{\current}{2}
    \FPifint{\test} \FPadd{\sum}{\sum}{\current} \fi
 
    \FPset{\prevprev}{\prev}
    \FPset{\prev}{\current}
    \FPadd{\current}{\prev}{\prevprev}
 
    \FPiflt{\current}{4000000} \setcounter{n}{0} \fi
}
 
\FPround{\sum}{\sum}{0}
 
The sum of all even valued Fibonacci Numbers below 4,000,000 is \FPprint{\sum}.
 
\end{document}
\end{lstlisting}

In \proglang{R}?

\begin{lstlisting}[language=rr]
fib <- c(1, 1)
i <- 3
while (fib[i-1] + fib[i-2] < 4e6){
  fib[i] <- fib[i-1]+fib[i-2]
  i <- i+1
}
 
sum(fib[which(fib %% 2 == 1)])
\end{lstlisting}

Which one of those is more readable to you?  This is an extension of the fact that math journals do not publish articles written in \proglang{C} or \proglang{Fortran}.  Those programming languages are the wrong mediums of abstraction for expressing highly complicated ideas to domain experts.  Only a madman would attempt to express deep mathematical abstraction in these languages for publication (implementation being an entirely separate issue).  

Likewise, we do not perform our statistical analyses in \LaTeX\ (don't be a pedant; we are not talking about sweave and you know it).  Of course, Matlab is much closer to the level of expressiveness we want in data science than \LaTeX.  But \proglang{R} is closer.







\section{Reductions and Transformations}


sum, prod, min, max, veiling, floor, round, abs, log, sqrt





\section{Matrix Arithmetic}


crossprod/tcrossprod (give timings)







\section{Matrix Factorizations}

svd, qr, chol
