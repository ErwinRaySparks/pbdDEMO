\chapter{Redistribution Methods}
\label{sec:redist}

One final challenge similar to, but distinct from reading in data is managing data which has already been read into the R processes.  Throughout this chapter, we will be making reference to several particulars to the block-cyclic data type used for objects of class \code{ddmatrix}.  As such, the reader is \emph{strongly} encouraged to be familiar with the content of the \pkg{pbdBASE} vignette before proceeding.

\section{Distributed Matrix Redistributions}

\emph{Example:  Convert between different distributed matrix distributions.}

The demo command is
\begin{Command}
### At the shell prompt, run the demo with 4 processors by
### (Use Rscript.exe for windows system)
mpiexec -np 4 Rscript -e "demo(reblock,'pbdDEMO',ask=F,echo=F)"
\end{Command}

The distributed matrix class \code{ddmatrix} has two components which can be specified, and modified, by the user to drastically affect the composition of the distributed matrix.  In particular, these are the object's block-cyclic blocking factor \code{bldim}, and the BLACS communicator number \code{CTXT} which controls how the data is block-cycled across the 2-dimensional processor grid.  

Thankfully, redistributing is a fairly simple process; though we would emphasize that \textbf{this is not free of cost}.  Reshaping data, especially at scale, can be much more expensive in total than even computation time.  That said, sometimes data must move.  It is better to get the job done slowly than to ``take your ball and go home'' with no results.  But we caution that if redistribution can be avoided, then it should, at all costs.

The demo relies on a utility from the \pkg{pbdBASE} package, namely \code{redistribute()}.  As the name implies, this method is for ``reshaping'' a block-cyclically distributed matrix of one kind to another.  Specifically, this takes an object of class \code{ddmatrix} as both an input and an output; i.e., and to emphasize the title of the chapter, this is not a method of \emph{distribution} but \emph{redistribution}.

For example, if I have a distributed matrix \code{dx} and I wish to reshape the distributed matrix so that it now has blocking dimension \code{newbldim} and is distributed across BLACS context \code{newCTXT}, then I need merely call:

\begin{lstlisting}[language=rr]
dy <- redistribute(dx, bldim=newbldim, ICTXT=newCTXT)
\end{lstlisting}








\section[Load Balance and Unload Balance]{Load Balance and Unload Balance}
\label{sec:lb_ub}

\emph{Example:  Load balancing (and unbalancing) distributed data.}

The demo command is
\begin{Command}
### At the shell prompt, run the demo with 4 processors by
### (Use Rscript.exe for windows system)
mpiexec -np 4 Rscript -e "demo(balance,'pbdDEMO',ask=F,echo=F)"
\end{Command}

Suppose we have an unbalanced, distributed input matrix \code{X.spmd}.  We can call \code{balance.info()} on this object to store some information about how to balance the data load across all processors.  This can be useful for tracking data movement, as well as for ``unbalancing'' later, if we so choose.  Next, we call \code{load.balance()} to obtain a load-balanced object \code{new.X.spmd}.  We can also now undo this entire process and get back to \code{X.spmd} by calling \code{unload.balance()} on \code{new.X.spmd}.

All together, the code looks something like:
\begin{Code}[title=R Code]
bal.info <- balance.info(X.spmd)
new.X.spmd <- load.balance(X.spmd, bal.info)
org.X.spmd <- unload.balance(new.X.spmd, bal.info)
\end{Code}

The details of this exchange are depicted in the example in Figure~\ref{fig:load_balnace}.  Here, 
\code{X.spmd} is unbalanced, and \code{new.X.spmd} is a balanced version of \code{X.spmd}.

\begin{figure}[h]
\label{fig:load_balnace}
\begin{center}
\begin{tabular}{ccc}
\code{X.spmd}(\code{org.X.spmd}) & & \code{new.X.spmd} \\

$
\left[
\begin{array}{ccc}
\color{p0}x_{1,1} & \color{p0}x_{1,2} & \color{p0}x_{1,3} \\ \hline
\color{p1}x_{2,1} & \color{p1}x_{2,2} & \color{p1}x_{2,3} \\
\color{p1}x_{3,1} & \color{p1}x_{3,2} & \color{p1}x_{3,3} \\ \hline
\color{p2}x_{4,1} & \color{p2}x_{4,2} & \color{p2}x_{4,3} \\
\color{p2}x_{5,1} & \color{p2}x_{5,2} & \color{p2}x_{5,3} \\
\color{p2}x_{6,1} & \color{p2}x_{6,2} & \color{p2}x_{6,3} \\ \hline
\color{p3}x_{7,1} & \color{p3}x_{7,2} & \color{p3}x_{7,3} \\
\color{p3}x_{8,1} & \color{p3}x_{8,2} & \color{p3}x_{8,3} \\
\color{p3}x_{9,1} & \color{p3}x_{9,2} & \color{p3}x_{9,3} \\
\color{p3}x_{10,1} & \color{p3}x_{10,2} & \color{p3}x_{10,3} \\
\end{array}
\right]
$

&

$
\begin{array}{c}
\mbox{\code{load.balance()}} \\
\longrightarrow \\
\hspace{0.5cm}\\
\longleftarrow \\
\mbox{\code{unload.balance()}} \\
\end{array}
$

&

$
\left[
\begin{array}{ccc}
\color{p0}x_{1,1} & \color{p0}x_{1,2} & \color{p0}x_{1,3} \\
\color{p0}x_{2,1} & \color{p0}x_{2,2} & \color{p0}x_{2,3} \\
\color{p0}x_{3,1} & \color{p0}x_{3,2} & \color{p0}x_{3,3} \\ \hline
\color{p1}x_{4,1} & \color{p1}x_{4,2} & \color{p1}x_{4,3} \\
\color{p1}x_{5,1} & \color{p1}x_{5,2} & \color{p1}x_{5,3} \\
\color{p1}x_{6,1} & \color{p1}x_{6,2} & \color{p1}x_{6,3} \\ \hline
\color{p2}x_{7,1} & \color{p2}x_{7,2} & \color{p2}x_{7,3} \\
\color{p2}x_{8,1} & \color{p2}x_{8,2} & \color{p2}x_{8,3} \\
\color{p2}x_{9,1} & \color{p2}x_{9,2} & \color{p2}x_{9,3} \\ \hline
\color{p3}x_{10,1} & \color{p3}x_{10,2} & \color{p3}x_{10,3} \\
\end{array}
\right]
$
\end{tabular}
\end{center}
\caption{
$\bX$ is distributed in
\code{X.spmd}(\code{org.X.spmd}) and \code{new.X.spmd}.
Both are distributed by row in 4 processors
where colors represents processor {\color{p0}0},
{\color{p1}1}, {\color{p2}2}, and {\color{p3}3}.
}
\end{figure}
 

The function \code{balance.info()} is extremely useful, because it will return the information used to load balance the given data \code{X.spmd}.  The return of \code{balance.info()} is a list consisting of two dataframes, \code{send} and \code{recv}, as well as two vectors, \code{N.allspmd} and \code{new.N.allspmd}.  

Here, \code{send} records the original processor rank and the destination processor rank of the unbalanced data (that which is to be transmitted by that processor).
The \code{load.balance()} function uses this table to move the data via \pkg{pbdMPI}'s \code{isend()} function.
If any ``destination rank'' is not the ``original rank'', then the corresponding data row will be moved to the appropriate processor.  On the other hand, \code{recv} records the original processor rank and the destination rank of balanced data (that which is received by that processor).

The \code{N.allspmd} and \code{new.N.allspmd} objects both have length equal to the communicator containing all numbers of rows of \code{X.spmd} before and after the balancing. This is for double checking and avoiding a 0-row matrix issue.

For \code{unload.balance}, the process amounts to reversing \code{bal.info} and passing it to \code{load.balance}.






\section{Convert Between SPMD and DMAT}
\label{sec:spmd_dmat}

\emph{Example:  Convert between SPMD and DMAT formats.}

The demo command is
\begin{Command}
### At the shell prompt, run the demo with 4 processors by
### (Use Rscript.exe for windows system)
mpiexec -np 4 Rscript -e "demo(spmd_dmat,'pbdDEMO',ask=F,echo=F)"
\end{Command}

As usual serial \proglang{R}, it is intuitively to read data in parallel
for each processor. We assume the input method is in SPMD to yield
data in \code{X.spmd}, and convert it into \code{ddmatrix}
format in \code{X.dmat}, then convert again to a \proglang{R}
object in \code{X} which is common on all processors, as in the next.
The Figure~\ref{fig:spmd_dmat} illustates an \code{X.spmd} and \code{X.dmat} conversion.  For more details about the block-cyclic data format used for class \code{ddmatrix}, see the \pkg{pbdBASE} vignette.
\begin{Code}[title=R Code]
X.dmat <- spmd2dmat(X.spmd)
X <- as.matrix(X.dmat)
new.X.spmd <- dmat2spmd(X.dmat)
\end{Code}
Note that we also provide a reversed function \code{dmat2spmd} for
\code{spmd2dmat}.

Here, the \code{spmd2dmat} function does the following:
\begin{enumerate}
\item Check numbers of columns of \code{X.spmd}, all
      processors should be the same.
\item Row balance the SPMD matrix, since number of rows of
      \code{X.spmd} may vary in different processors.
\item Call \code{new} on the balanced matrix to yield a \code{ddmatrix} object,
      says \code{X.dmat}, in block context 2 (\code{ICTXT = 2}).
\item Convert the \code{X.dmat} to other block contexts
      (default\code{ICTXT = 0}) via \code{base.reblock}.
\end{enumerate}
Note that the first step is done by the \code{load.balance} function
(Section~\ref{sec:lb_ub})
which is particular useful to balance SPMD matrix and yield performance
even the matrix is not in block-cyclic format.

\begin{figure}
\label{fig:spmd_dmat}
\begin{center}
\begin{tabular}{ccc}
\code{X.spmd} & & \code{X.dmat} \\

$
\left[
\begin{array}{ccc}
\color{p0}x_{1,1} & \color{p0}x_{1,2} & \color{p0}x_{1,3} \\ \hline
\color{p1}x_{2,1} & \color{p1}x_{2,2} & \color{p1}x_{2,3} \\
\color{p1}x_{3,1} & \color{p1}x_{3,2} & \color{p1}x_{3,3} \\ \hline
\color{p2}x_{4,1} & \color{p2}x_{4,2} & \color{p2}x_{4,3} \\
\color{p2}x_{5,1} & \color{p2}x_{5,2} & \color{p2}x_{5,3} \\
\color{p2}x_{6,1} & \color{p2}x_{6,2} & \color{p2}x_{6,3} \\ \hline
\color{p3}x_{7,1} & \color{p3}x_{7,2} & \color{p3}x_{7,3} \\
\color{p3}x_{8,1} & \color{p3}x_{8,2} & \color{p3}x_{8,3} \\
\color{p3}x_{9,1} & \color{p3}x_{9,2} & \color{p3}x_{9,3} \\
\color{p3}x_{10,1} & \color{p3}x_{10,2} & \color{p3}x_{10,3} \\
\end{array}
\right]
$

&

$
\begin{array}{c}
\mbox{\code{spmd2dmat}} \\
\longrightarrow \\
\hspace{0.5cm}\\
\longleftarrow \\
\mbox{\code{dmat2spmd}} \\
\end{array}
$

&

$
\left[
\begin{array}{cc|c}
\color{p0}x_{1,1} & \color{p0}x_{1,2} & \color{p1}x_{1,3} \\
\color{p0}x_{2,1} & \color{p0}x_{2,2} & \color{p1}x_{2,3} \\ \hline
\color{p2}x_{3,1} & \color{p2}x_{3,2} & \color{p3}x_{3,3} \\
\color{p2}x_{4,1} & \color{p2}x_{4,2} & \color{p3}x_{4,3} \\ \hline
\color{p0}x_{5,1} & \color{p0}x_{5,2} & \color{p1}x_{5,3} \\
\color{p0}x_{6,1} & \color{p0}x_{6,2} & \color{p1}x_{6,3} \\ \hline
\color{p2}x_{7,1} & \color{p2}x_{7,2} & \color{p3}x_{7,3} \\
\color{p2}x_{8,1} & \color{p2}x_{8,2} & \color{p3}x_{8,3} \\ \hline
\color{p0}x_{9,1} & \color{p0}x_{9,2} & \color{p1}x_{9,3} \\
\color{p0}x_{10,1} & \color{p0}x_{10,2} & \color{p1}x_{10,3} \\
\end{array}
\right]
$
\end{tabular}
\end{center}
\caption{
$\bX$ is distributed in
\code{X.spmd} and \code{X.dmat}.
Both are distributed in 4 processors
where colors represents processor {\color{p0}0},
{\color{p1}1}, {\color{p2}2}, and {\color{p3}3}.
Note that \code{X.dmat} is in block-cyclic format of
$2\times 2$ grid with $2\times 2$ block dimension.
}
\end{figure}
